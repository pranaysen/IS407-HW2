[
  {
    "objectID": "posts/pokemon/index.html",
    "href": "posts/pokemon/index.html",
    "title": "Exploring the Pokemon Data Set",
    "section": "",
    "text": "Pokemon is a franchise that is very dear to me. Unfortunately I don’t have the time to play it like I once did, but I can still connect with it through the power of data science! Let’s explore the pokemon data set and see what we can find. I’m taking my data from Rounak Banik’s pokemon data set found here. Download the dataset and follow along with this code if you’d like to try it for yourself!\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\npokemon &lt;- read.csv(\"pokemon.csv\")\n\nA quick way to find out how many pokemon there are is to see the number of observations in this dataset. We can do that really easily, as follows:\n\nnrow(pokemon)\n\n[1] 801\n\n\nThis dataset is formatted such that each row represents the information for a given pokemon. If we find the total number of rows, that should give us the total number of pokemon in this set. It’s worth noting that this dataset is a bit outdated - this does not include pokemon introduced in generations 8 (released in 2019) and 9 (released in 2022). I’m okay with that because generation 7 (released in 2016) is my favorite, and the last generation that I’ve played.\nEveryone knows that pokemon have types! Let’s see what the distribution of primary types is like:\n\nggplot(data = pokemon, aes(y = type1)) +\n  geom_bar() +\n  ylab(\"Primary Type\")\n\n\n\n\nFrom this graph, it’s clear to see that water is the most common primary type among all pokemon, and flying is the least common primary type. Does that necessarily mean that there are more water pokemon than flying pokemon? Let’s take a look at the distribution for secondary types:\n\nggplot(data = pokemon, aes(y = type2)) +\n  geom_bar() +\n  ylab(\"Secondary Type\")\n\n\n\n\nThis certainly changes things! Right away it’s clear that the most common secondary type is … no secondary type at all! The majority of pokemon out there are monotype, as of generation 7. Let’s remove the monotypes from the secondary type graph to get a clearer picture:\n\nggplot(data = pokemon %&gt;% filter(type2 != \"\"), aes(y =type2)) +\n  geom_bar() +\n  ylab(\"Secondary Type\")\n\n\n\n\nIf you were just looking at secondary types, it’s abundantly clear that flying is the most common. Let’s take a look at the counts of water and flying when it’s either in the primary or secondary type slot. Let’s create some new variables {r} has_water and {r} has_flying that tells us if either water or flying is any of the two type slots:\n\npokemon &lt;- pokemon %&gt;% \n  mutate(has_water = as.logical(type1 == \"water\" | type2 == \"water\")) %&gt;% \n  mutate(has_flying = as.logical(type1 == \"flying\" | type2 == \"flying\"))\n\npokemon %&gt;% \n  filter(has_water == TRUE) %&gt;% \n  nrow()\n\n[1] 131\n\npokemon %&gt;% \n  filter(has_flying == TRUE) %&gt;% \n  nrow()\n\n[1] 98\n\npokemon %&gt;% \n  filter(has_water == TRUE & has_flying == TRUE) %&gt;% \n  select(name)\n\n      name\n1 Gyarados\n2  Mantine\n3  Wingull\n4 Pelipper\n5  Mantyke\n6 Ducklett\n7   Swanna\n\n\nIt’s closer than you think it would be at first glance, but water is definitely the more common type: 131 water type pokemon compared to 98 flying type pokemon. There are also 7 pokemon who are both water and flying - their names are listed above.\nLet’s get a breakdown of how many new pokemon were introduced in each generation!\n\nggplot(data = pokemon, aes(y = generation)) +\n  geom_bar() +\n  scale_y_continuous(n.breaks = 7)\n\n\n\n\nGenerations 1 and 5 introduced the most new pokemon, while generation 6 introduced the least. That’s a bit disheartening to me, as generation 6 was when I first started playing pokemon.\nI’m curious as to how many new pokemon of each primary type each generation introduced. Let’s see if we can visualize that.\n\nggplot(data = pokemon, aes(y = generation, fill = type1)) +\n  geom_bar() +\n  scale_y_continuous(n.breaks = 7)\n\n\n\n\nLet’s take a look at stat totals now!\n\npokemon &lt;- pokemon %&gt;% \n  mutate(stat_total = hp + attack + defense + sp_attack + sp_defense + speed)\n\nggplot(data = pokemon, aes(x = stat_total)) + \n  geom_bar(stat = \"bin\", binwidth = 20)\n\n\n\n\nThis graph appears bimodal, almost trimodal in nature. There are lots of pokemon with stat totals around 300, some with stat totals around 400, and lots with totals around 500. This makes sense in the context of pokemon evolution. Middle and single evolution pokemon are more likely to have stat totals around 400, while pokemon evolution lines with 2 stages will be distributed more towards 300 for lower evolutions and 500 for higher evolutions. I’m curious to see how this compares with legendaries though.\n\nggplot(data = pokemon, aes(x = stat_total)) + \n  geom_bar(stat = \"bin\", binwidth = 20) +\n  facet_wrap(~ is_legendary)\n\n\n\n\nLooks like stat totals above 550 are largely reserved for legendary pokemon. That isn’t to say this will always be the case though - looks like there’s one legendary pokemon with a stat total around 200. I bet you it’s Cosmog.\n\npokemon %&gt;% \n  filter(name == \"Cosmog\") %&gt;% \n  select(stat_total)\n\n  stat_total\n1        200\n\n\nRight on the money.\nImage taken from Bulbapedia."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pranay’s Data Science Blog",
    "section": "",
    "text": "Thanks for stopping by Pranay’s Data Science blog! You can find out a little more about me in via the aptly-named About Me link in the top right, and you can check out some of my posts below.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nBuilding Up to an Effective Visualization of the Generic Ballot\n\n\n\n\n\n\n\npolitics\n\n\ndata science\n\n\ndata visualization\n\n\n\n\n\n\n\n\n\n\n\nNov 5, 2023\n\n\nPranay Sen\n\n\n\n\n\n\n  \n\n\n\n\nExploring the Pokemon Data Set\n\n\n\n\n\n\n\ndata science\n\n\ndata set exploration\n\n\ndata visualization\n\n\n\n\n\n\n\n\n\n\n\nNov 5, 2023\n\n\nPranay Sen\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Hello, and welcome to my blog! This is a simple blog where I’ll be discussing some cool data science topics with some interesting data sets behind them. But first, a little bit about me.\nMy name is Pranay and I am (currently) a second year Master’s student at the University of Illinois at Urbana-Champaign. My major is computer engineering, and my thesis is on the usage of reinforcement learning AI models and the application of brain stimulation in treating Alzheimer’s disease patients. I’m taking this data science course as I view data science and AI/ML as going hand in hand with each other. I graduated from UIUC for my Bachelor’s in computer engineering as well, and I recently won the Olsen award for graduate teaching for my work as a TA in ECE 120, an introductory computer engineering course at the university.\nMy hobbies include gaming, anime/manga, going to the gym, and cooking. For games, I love the Persona series, Overwatch, and basically anything Nintendo. My favorite animanga series are JoJo’s Bizarre Adventure, One Piece, and Chainsaw Man. I’m trying to cook something new every week too, and it’s been going great so far!"
  },
  {
    "objectID": "posts/generic_ballot/index.html",
    "href": "posts/generic_ballot/index.html",
    "title": "Building Up to an Effective Visualization of the Generic Ballot",
    "section": "",
    "text": "I’ve been fascinated by politics for the past couple years now, and luckily enough, politics is an awesome area to get some data science skills! With new polls releasing all the time and political forecasts changing by the minute, there’s a wealth of data on the internet that can show you how public sentiment in politics has changed over time. Gallup has been publishing their public polls since 1935!\nIn this post, we’ll be tracking the generic ballot over time. The generic ballot refers to whether Americans would prefer to have a generic Republican or a generic Democrat in office. This is a great way to see how political ideologies gain and lose popularity over time! FiveThirtyEight has a dataset tracking the high and low points each day for each party on the generic ballot. We’ll be using that dataset in our exploration today. You can find the full generic ballot dataset here.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\nballot &lt;- read.csv(\"https://projects.fivethirtyeight.com/polls/data/generic_ballot_averages.csv\")\nhead(ballot)\n\n    candidate pct_estimate       lo       hi       date   election cycle\n1   Democrats     43.94449 39.33347 48.55550 2017-04-15 2018-11-06  2018\n2 Republicans     39.54969 34.93867 44.16071 2017-04-15 2018-11-06  2018\n3   Democrats     43.74965 39.14054 48.35876 2017-04-16 2018-11-06  2018\n4 Republicans     39.59254 34.98343 44.20165 2017-04-16 2018-11-06  2018\n5   Democrats     43.74553 39.13599 48.35508 2017-04-17 2018-11-06  2018\n6 Republicans     39.58794 34.97840 44.19749 2017-04-17 2018-11-06  2018\n\n\nThis dataset has 3,480 observations, and two observations are needed for one day’s worth of data. The first observation per day shows the upper bound (hi), lower bound (lo), and estimated percentage of Americans who want Democrats in office. The second observation per day shows the same information for Republicans. Let’s try to graph this data as best we can. The first thing we should do is convert the date column into something a little more graph-friendly:\n\nballot &lt;- ballot %&gt;% mutate(date = as.Date(date, format = \"%Y-%m-%d\"))\nhead(ballot)\n\n    candidate pct_estimate       lo       hi       date   election cycle\n1   Democrats     43.94449 39.33347 48.55550 2017-04-15 2018-11-06  2018\n2 Republicans     39.54969 34.93867 44.16071 2017-04-15 2018-11-06  2018\n3   Democrats     43.74965 39.14054 48.35876 2017-04-16 2018-11-06  2018\n4 Republicans     39.59254 34.98343 44.20165 2017-04-16 2018-11-06  2018\n5   Democrats     43.74553 39.13599 48.35508 2017-04-17 2018-11-06  2018\n6 Republicans     39.58794 34.97840 44.19749 2017-04-17 2018-11-06  2018\n\n\nGgplot2 recognizes dates when formatted as the date data type - not as characters. This should make graphing a ton easier for us! Let’s see how the Democrats do over time:\n\nggplot(data = ballot %&gt;% filter(candidate == \"Democrats\"), mapping = aes(x = date, y = pct_estimate)) +\n  geom_line(color = \"blue\") + \n  scale_x_date(date_breaks = \"6 months\", date_labels =  \"%b %y\")  +\n  ylab(\"Democrats' Generic Ballot Percentage\")\n\n\n\n\nAwesome! Let’s do the same for Republicans:\n\nggplot(data = ballot %&gt;% filter(candidate == \"Republicans\"), mapping = aes(x = date, y = pct_estimate)) +\n  geom_line(color = \"red\") + \n  scale_x_date(date_breaks = \"6 months\", date_labels =  \"%b %y\") +\n  ylab(\"Republicans' Generic Ballot Percentage\")\n\n\n\n\nThese graphs are decent when presented on their own, but they don’t mean too much without context. Let’s try putting both plots on the same graph:\n\nggplot() +\n  geom_line(data = ballot %&gt;% filter(candidate == \"Democrats\"), mapping = aes(x = date, y = pct_estimate), color = \"blue\") +\n  geom_line(data = ballot %&gt;% filter(candidate == \"Republicans\"), mapping = aes(x = date, y = pct_estimate), color = \"red\") + \n  scale_x_date(date_breaks = \"6 months\", date_labels =  \"%b %y\") +\n  ylab(\"Party's Generic Ballot Percentage\")\n\n\n\n\nJust at a glance, you get so much more information from this one graph! You can see how Democrats fare versus Republicans concisely and clearly in one graph.\nLet’s say, for the sake of example, that we didn’t trust FiveThirtyEight’s estimate of how each party is doing. We could plot the high and low points of each party on each day alongside FiveThirtyEight’s estimate to see the range of possible estimates.\n\nggplot() +\n  geom_line(data = ballot %&gt;% filter(candidate == \"Democrats\"), mapping = aes(x = date, y = pct_estimate), color = \"blue\") +\n  geom_ribbon(data = ballot %&gt;% filter(candidate == \"Democrats\"), mapping = aes(x= date, y = pct_estimate, ymin = lo, ymax = hi), fill = \"blue\", alpha = 0.2) +\n  geom_line(data = ballot %&gt;% filter(candidate == \"Republicans\"), mapping = aes(x = date, y = pct_estimate), color = \"red\") + \n  geom_ribbon(data = ballot %&gt;% filter(candidate == \"Republicans\"), mapping = aes(x= date, y = pct_estimate, ymin = lo, ymax = hi), fill = \"red\", alpha = 0.2) +\n  scale_x_date(date_breaks = \"6 months\", date_labels =  \"%b %y\") +\n  ylab(\"Party's Generic Ballot Percentage\")\n\n\n\n\nThis reveals a lot more than you may initially think! If FiveThirtyEight’s estimate was off on a particular day, we can see valid error bounds for this estimate. In the areas shaded, purple, it could be that the opposite party is ahead on the generic ballot!\nOne last thing we can do to make this visualization really complete is to add a legend to this plot. While we may intuit that Democrats are represented with blue and Republicans with red, we should make that assumption explicit. We should not leave something like this up to interpretation when our goal is to visualize data cleanly and effectively.\n\nlegend_colors &lt;- c(\"Democrats\" = \"blue\", \"Republicans\" = \"red\")\n\nggplot(ballot) +\n  geom_line(data = ballot %&gt;% filter(candidate == \"Democrats\"), mapping = aes(x = date, y = pct_estimate, color = \"Democrats\")) +\n  geom_ribbon(data = ballot %&gt;% filter(candidate == \"Democrats\"), mapping = aes(x= date, y = pct_estimate, ymin = lo, ymax = hi), fill = \"blue\", alpha = 0.2) +\n  geom_line(data = ballot %&gt;% filter(candidate == \"Republicans\"), mapping = aes(x = date, y = pct_estimate, color = \"Republicans\")) + \n  geom_ribbon(data = ballot %&gt;% filter(candidate == \"Republicans\"), mapping = aes(x= date, y = pct_estimate, ymin = lo, ymax = hi), fill = \"red\", alpha = 0.2) +\n  scale_x_date(date_breaks = \"6 months\", date_labels =  \"%b %y\") +\n  xlab(\"Date\") +\n  ylab(\"Party's Generic Ballot Percentage\") +\n  labs(color = \"Generic Candidate Party\") +\n  scale_color_manual(values = legend_colors) +\n  theme(legend.position = \"bottom\")\n\n\n\n\nAnd there we have it! An effective visualization of the generic ballot over time, complete with error bands. I could spend ages talking about the story this graph tells, but that requires way more political insight than what I can provide on this data science blog. Hope you enjoyed!\n(Image taken from Vox)"
  }
]